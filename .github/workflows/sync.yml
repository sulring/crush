name: Sync and Build with Upstream
permissions:
  contents: write
on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours to catch new tags
  workflow_dispatch:
    inputs:
      build_current:
        description: 'Build current custom version (ignores upstream check)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  sync-and-build:
    runs-on: ubuntu-latest
    outputs:
      update_needed: ${{ steps.check.outputs.update_needed }}
      latest_tag: ${{ steps.tags.outputs.latest_tag }}
      target_tag: ${{ steps.target.outputs.target_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: custom-keyboard-mappings
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Add upstream remote
        run: git remote add upstream https://github.com/charmbracelet/crush.git
      
      - name: Fetch upstream tags and branches
        run: |
          git fetch upstream --tags --force
          git fetch upstream main
      
      - name: Get current and latest tags
        id: tags
        run: |
          # Find latest upstream tag reachable from upstream/main
          LATEST_TAG=$(git describe --tags --abbrev=0 upstream/main 2>/dev/null || echo "v0.0.0")
          # Current tag on this repo (before any deletion)
          CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "current_tag=$CURRENT_TAG" >> $GITHUB_OUTPUT
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Current: $CURRENT_TAG, Latest: $LATEST_TAG"
      
      - name: Check if update needed
        id: check
        run: |
          if [ "${{ github.event.inputs.build_current }}" = "true" ]; then
            echo "Manual build requested"
            echo "update_needed=true" >> $GITHUB_OUTPUT
          elif [ "${{ steps.tags.outputs.current_tag }}" = "${{ steps.tags.outputs.latest_tag }}" ]; then
            echo "Already have tag for ${{ steps.tags.outputs.latest_tag }}"
            echo "update_needed=false" >> $GITHUB_OUTPUT
          else
            echo "New upstream tag available"
            echo "update_needed=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Determine target tag
        id: target
        run: |
          if [ "${{ github.event.inputs.build_current }}" = "true" ]; then
            echo "target_tag=${{ steps.tags.outputs.latest_tag }}" >> $GITHUB_OUTPUT
          else
            echo "target_tag=${{ steps.tags.outputs.latest_tag }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Rebase and create release tag
        if: steps.check.outputs.update_needed == 'true'
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "7470800+sulring@users.noreply.github.com"
          # Ensure branch is present locally
          git fetch origin custom-keyboard-mappings:custom-keyboard-mappings || true
          git checkout custom-keyboard-mappings
          # Attempt rebase
          TARGET=${{ steps.target.outputs.target_tag }}
          # Try rebase on tag first, fallback to main if tag doesn't exist
          if git rev-parse upstream/$TARGET >/dev/null 2>&1; then
            echo "Rebasing onto upstream tag: upstream/$TARGET"
            git rebase upstream/$TARGET
          elif git rev-parse $TARGET >/dev/null 2>&1; then
            echo "Rebasing onto local tag: $TARGET"
            git rebase $TARGET
          else
            echo "Tag $TARGET not found, rebasing onto main"
            git rebase upstream/main
          fi
          git push origin custom-keyboard-mappings --force-with-lease
          # Create the SAME tag as upstream for release
          echo "Preparing tag $TARGET"
          # Delete tag on fork if it exists, then recreate on the rebased commit
          git tag -d "$TARGET" >/dev/null 2>&1 || true
          git push origin :refs/tags/"$TARGET" || true
          echo "Creating new tag $TARGET"
          git tag "$TARGET"
          git push origin "$TARGET"

  build:
    needs: sync-and-build
    if: needs.sync-and-build.outputs.update_needed == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        goos: [linux, darwin, windows]
        goarch: [amd64, arm64]
        exclude:
          - goos: windows
            goarch: arm64
    steps:
      - name: Checkout custom branch for building
        uses: actions/checkout@v4
        with:
          ref: custom-keyboard-mappings
      
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'
      
      - name: Build
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
        run: |
          VERSION=${{ needs.sync-and-build.outputs.latest_tag }}
          BINARY_NAME=crush-${{ matrix.goos }}-${{ matrix.goarch }}
          
          if [ "${{ matrix.goos }}" = "windows" ]; then
            BINARY_NAME=${BINARY_NAME}.exe
          fi
          
          go build -ldflags="-X github.com/charmbracelet/crush/internal/version.Version=${VERSION}" -o ${BINARY_NAME} .
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: crush-${{ matrix.goos }}-${{ matrix.goarch }}
          path: crush-*

  release:
    needs: [sync-and-build, build]
    if: needs.sync-and-build.outputs.update_needed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.sync-and-build.outputs.target_tag }}
          name: ${{ needs.sync-and-build.outputs.target_tag }} (Custom Keyboard Mappings)
          body: |
            Auto-built version of crush with custom keyboard mappings
            
            Based on upstream tag: ${{ needs.sync-and-build.outputs.target_tag }}
            
            Changes:
            - Custom keyboard key mappings across components
            - Rebased on latest upstream changes
          draft: false
          prerelease: false
          files: |
            artifacts/*/crush-*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
